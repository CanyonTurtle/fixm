<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixm Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
        }
        
        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            max-width: 100vw;
            max-height: 100vh;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        /* Desktop: max 800x600 centered */
        @media (min-width: 801px) {
            canvas {
                max-width: 800px;
                max-height: 600px;
            }
        }
        
        /* Mobile: fill screen with proper aspect */
        @media (max-width: 800px) {
            body {
                overflow: hidden;
            }
            canvas {
                width: 100vw !important;
                height: 100vh !important;
                object-fit: contain;
            }
        }
        
        /* Fullscreen toggle button */
        .fullscreen-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: all 0.2s ease;
            user-select: none;
            touch-action: manipulation;
        }
        
        .fullscreen-toggle:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        .fullscreen-toggle:active {
            transform: scale(0.95);
        }
        
        .fullscreen-toggle svg {
            width: 20px;
            height: 20px;
            fill: rgba(255, 255, 255, 0.8);
        }
        
        .fullscreen-toggle:hover svg {
            fill: rgba(255, 255, 255, 1);
        }
        
        /* Hide fullscreen button when already in fullscreen */
        .fullscreen-active .fullscreen-toggle {
            opacity: 0.5;
        }
        
        .fullscreen-active .fullscreen-toggle:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Spritesheet definition using web components -->
        <fixm-spritesheet name="test">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAI1JREFUOE+tk1ESgCAIROEAdf9z2gFwZMAQobGyn5JZnuSuCPFDQRkjqS9yI5VZimevDT12QVGjRwmo9+nHUrPCLGQL4NXufoo2wQg4xIDLHE9Q098IAYg4ONHERARgoDkgCUbmxjyBKHnXAqDvJwBnx2fABGcK1nYbdbolO7Mkdsifu2DP6fNtXDTxllUd3joRPnwYoQAAAABJRU5ErkJggg==" alt="Test Sprite" style="display: none;">
        </fixm-spritesheet>
    </div>
    
    <!-- Fullscreen toggle button -->
    <div class="fullscreen-toggle" id="fullscreen-toggle" title="Toggle Fullscreen">
        <svg viewBox="0 0 24 24">
            <path id="fullscreen-icon" d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
        </svg>
    </div>
    
    <script src="fixm.js"></script>
    <script>
        // Initialize Fixm with custom settings
        Fixm.init({
            width: 320,
            height: 240,
            mode: 'truecolor'
            // showStartup: false  // Uncomment to disable startup animation
        });
        
        // Game state
        let gameState = 'menu';
        let selectedMenuItem = 0;
        let frame = 0;
        let playerX = 150;
        let playerY = 110;
        let lastInputTime = 0;
        
        // Menu items
        const menuItems = [
            { name: 'Rectangles Demo', state: 'rects' },
            { name: 'Sprite Demo', state: 'sprite' },
            { name: 'Animation Demo', state: 'animate' },
            { name: 'Input Demo', state: 'input' },
            { name: 'Audio Test', state: 'audio' },
            { name: 'Clear Screen', state: 'clear' }
        ];
        
        // Set up the main update loop
        Fixm.setUpdate((deltaTime) => {
            frame++;
            const gamepad = Fixm.getGamepad(0);
            
            // Handle input with timing to prevent rapid menu changes
            if (frame - lastInputTime > 10) {
                if (gameState === 'menu') {
                    if (gamepad & Fixm.BUTTON_UP) {
                        selectedMenuItem = (selectedMenuItem - 1 + menuItems.length) % menuItems.length;
                        lastInputTime = frame;
                    }
                    if (gamepad & Fixm.BUTTON_DOWN) {
                        selectedMenuItem = (selectedMenuItem + 1) % menuItems.length;
                        lastInputTime = frame;
                    }
                    if (gamepad & (Fixm.BUTTON_A | Fixm.BUTTON_B)) {
                        gameState = menuItems[selectedMenuItem].state;
                        if (gameState === 'input') {
                            playerX = 150;
                            playerY = 110;
                        }
                        if (gameState === 'audio') {
                            playSound();
                        }
                        lastInputTime = frame;
                    }
                } else {
                    // Return to menu from any demo
                    if (gamepad & (Fixm.BUTTON_X | Fixm.BUTTON_Y)) {
                        gameState = 'menu';
                        lastInputTime = frame;
                    }
                }
            }
            
            // Render current state
            switch(gameState) {
                case 'menu':
                    updateMenu();
                    break;
                case 'rects':
                    updateRects();
                    break;
                case 'sprite':
                    updateSprite();
                    break;
                case 'animate':
                    updateAnimate();
                    break;
                case 'input':
                    updateInput();
                    break;
                case 'clear':
                    updateClear();
                    break;
            }
            
            Fixm.present();
        });
        
        function updateMenu() {
            Fixm.clear(0x001133);
            
            // Title
            Fixm.drawText('FIXM GAME LIBRARY', 70, 20, 0xFFFFFF);
            Fixm.drawText('DEMO MENU', 110, 35, 0xCCCCCC);
            
            // Menu items
            for (let i = 0; i < menuItems.length; i++) {
                const y = 70 + i * 15;
                const color = i === selectedMenuItem ? 0xFFFF00 : 0xAAAAAAA;
                
                if (i === selectedMenuItem) {
                    Fixm.drawText('>', 60, y, 0xFFFF00);
                }
                
                Fixm.drawText(menuItems[i].name.toUpperCase(), 80, y, color);
            }
            
            // Instructions
            Fixm.drawText('UP DOWN A B TO SELECT', 80, 200, 0x888888);
            Fixm.drawText('X Y TO RETURN TO MENU', 85, 215, 0x888888);
        }

        function updateRects() {
            Fixm.clear(0x001122);
            
            // Draw some colorful rectangles
            Fixm.drawRect(10, 10, 50, 30, 0xFF0000); // Red
            Fixm.drawRect(70, 15, 40, 25, 0x00FF00); // Green
            Fixm.drawRect(120, 20, 35, 35, 0x0000FF); // Blue
            Fixm.drawRect(200, 10, 60, 20, 0xFFFF00); // Yellow
            Fixm.drawRect(50, 60, 80, 40, 0xFF00FF); // Magenta
            
            // Draw a gradient-like pattern
            for (let x = 0; x < 160; x++) {
                for (let y = 120; y < 140; y++) {
                    const color = (x << 16) | ((y - 120) * 12 << 8) | 128;
                    Fixm.setPixel(x, y, color);
                }
            }
            
            Fixm.drawText('RECTANGLES DEMO', 180, 180, 0xFFFFFF);
        }
        
        function updateSprite() {
            Fixm.clear(0x000044);
            
            // Get and display image info
            const imageInfo = Fixm.getImageInfo('test');
            if (imageInfo) {
                Fixm.drawText(`SIZE: ${imageInfo.width}X${imageInfo.height}`, 10, 10, 0xFFFF00);
            }
            
            // Draw the test sprite multiple times
            for (let i = 0; i < 8; i++) {
                Fixm.blitSub(0, 0, 15, 15, 50 + i * 20, 50 + i * 10, 'test');
            }
            
            Fixm.drawText('SPRITE DEMO', 200, 180, 0xFFFFFF);
        }
        
        function updateAnimate() {
            // Clear with animated background color
            const bgColor = Math.floor(Math.sin(frame * 0.02) * 32 + 32);
            Fixm.clear(bgColor << 16 | bgColor << 8 | bgColor * 2);
            
            // Animated rectangles
            for (let i = 0; i < 5; i++) {
                const x = Math.sin(frame * 0.03 + i) * 100 + 160;
                const y = Math.cos(frame * 0.04 + i * 0.5) * 80 + 120;
                const color = ((frame + i * 50) % 255) << ((i % 3) * 8);
                Fixm.drawRect(Math.floor(x), Math.floor(y), 20, 20, color);
            }
            
            // Animated sprites
            const spriteX = Math.sin(frame * 0.05) * 140 + 160;
            const spriteY = Math.cos(frame * 0.03) * 100 + 120;
            Fixm.blitSub(0, 0, 8, 8, Math.floor(spriteX), Math.floor(spriteY), 'test');
            
            Fixm.drawText('ANIMATION DEMO', 190, 20, 0xFFFFFF);
        }
        
        function updateInput() {
            const gamepad = Fixm.getGamepad(0);
            
            // Move player based on input
            if (gamepad & Fixm.BUTTON_LEFT) playerX -= 2;
            if (gamepad & Fixm.BUTTON_RIGHT) playerX += 2;
            if (gamepad & Fixm.BUTTON_UP) playerY -= 2;
            if (gamepad & Fixm.BUTTON_DOWN) playerY += 2;
            
            // Keep player in bounds
            playerX = Math.max(0, Math.min(playerX, 300));
            playerY = Math.max(0, Math.min(playerY, 220));
            
            // Clear screen
            Fixm.clear(0x001122);
            
            // Draw player
            Fixm.drawRect(playerX, playerY, 20, 20, 0xFFFFFF);
            
            // Draw button indicators
            if (gamepad & Fixm.BUTTON_A) Fixm.drawRect(10, 10, 30, 20, 0xFF0000);
            if (gamepad & Fixm.BUTTON_B) Fixm.drawRect(50, 10, 30, 20, 0x00FF00);
            if (gamepad & Fixm.BUTTON_X) Fixm.drawRect(90, 10, 30, 20, 0x0000FF);
            if (gamepad & Fixm.BUTTON_Y) Fixm.drawRect(130, 10, 30, 20, 0xFFFF00);
            
            Fixm.drawText('INPUT DEMO', 200, 200, 0xFFFFFF);
            Fixm.drawText('MOVE WITH WASD ARROWS', 140, 215, 0xCCCCCC);
        }
        
        
        function updateClear() {
            Fixm.clear(0x000000);
            Fixm.drawText('CLEAR SCREEN', 200, 120, 0x444444);
        }
        
        function playSound() {
            // Play a simple melody
            Fixm.channelSet(0, 440, 'sine'); // A4
            setTimeout(() => Fixm.channelSet(0, 523, 'sine'), 200); // C5
            setTimeout(() => Fixm.channelSet(0, 659, 'sine'), 400); // E5
            setTimeout(() => Fixm.channelSet(0, 0), 600); // Stop
        }
        
        // Fullscreen functionality
        let isFullscreen = false;
        
        function toggleFullscreen() {
            if (!isFullscreen) {
                // Enter fullscreen
                const element = document.documentElement;
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                } else if (element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                } else if (element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }
        
        function updateFullscreenState() {
            isFullscreen = !!(document.fullscreenElement || 
                             document.webkitFullscreenElement || 
                             document.mozFullScreenElement || 
                             document.msFullscreenElement);
            
            document.body.classList.toggle('fullscreen-active', isFullscreen);
            
            // Update icon
            const icon = document.getElementById('fullscreen-icon');
            if (isFullscreen) {
                // Exit fullscreen icon
                icon.setAttribute('d', 'M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z');
            } else {
                // Enter fullscreen icon
                icon.setAttribute('d', 'M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z');
            }
        }
        
        // Fullscreen event listeners
        document.getElementById('fullscreen-toggle').addEventListener('click', toggleFullscreen);
        document.getElementById('fullscreen-toggle').addEventListener('touchstart', (e) => {
            e.preventDefault();
            toggleFullscreen();
        });
        
        // Listen for fullscreen changes
        document.addEventListener('fullscreenchange', updateFullscreenState);
        document.addEventListener('webkitfullscreenchange', updateFullscreenState);
        document.addEventListener('mozfullscreenchange', updateFullscreenState);
        document.addEventListener('MSFullscreenChange', updateFullscreenState);
        
        // Escape key and back button handling
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isFullscreen) {
                toggleFullscreen();
            }
        });
        
        // Handle Android back button
        window.addEventListener('popstate', (e) => {
            if (isFullscreen) {
                e.preventDefault();
                toggleFullscreen();
                history.pushState(null, null, location.href);
            }
        });
        
        // Push state to handle back button on mobile
        if (history.pushState) {
            history.pushState(null, null, location.href);
        }
        
        console.log('Fixm Demo Ready!');
        console.log('Use UP/DOWN + A/B to navigate menu, X/Y to return to menu');
        console.log('Click fullscreen icon or press F11 for fullscreen mode');
    </script>
</body>
</html>